# ──────────────────────────────────────────────────────────────────────────────
# File: .github/workflows/baidupan-to-release.yml
# 用途：手动触发；通过 BaiduPCS-Go（仅 Cookie 登录，Secrets: BAIDU_COOKIE）
#      从百度网盘按“逗号分隔的完整**文件**路径”逐个下载；单文件>阈值则分卷；
#      每个文件完成后立刻上传到 Release 并清理本地，再处理下一个。
# 说明：
#  1) 仅文件路径，不支持目录，不支持分享链接。
#  2) 严格顺序：下载1个 →（必要时分卷）上传 → 删除本地 → 下一个。
#  3) Release 信息（tag/name/body/draft/prerelease/target）运行时填写；tag 必填。
#  4) 默认分卷阈值 2048MB（≈2GB）；可在触发时调整。
# ──────────────────────────────────────────────────────────────────────────────

name: BaiduPan → GitHub Release

on:
  workflow_dispatch:
    inputs:
      tag:
        description: "Release tag（若不存在会自动创建）"
        required: true
      name:
        description: "Release 名称（可选，不填则同 tag）"
        required: false
      body:
        description: "Release 说明（可选，多行可）"
        required: false
      draft:
        description: "是否创建为 Draft（true/false）"
        default: "false"
        required: true
      prerelease:
        description: "是否标记为 Pre-release（true/false）"
        default: "false"
        required: true
      target:
        description: "目标提交/分支（默认当前默认分支）"
        required: false
      baidupan_files:
        description: |
          逗号分隔的“文件完整路径”（仅文件，非目录）。
          例：/我的资源/文件1.iso, /我的资源/文件2.zip
        required: true
      part_size_mb:
        description: "分卷大小（MB），默认 2048（≈2GB）"
        default: "1900"
        required: true

permissions:
  contents: write

jobs:
  run:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install base deps
        shell: bash
        run: |
          set -euxo pipefail
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends \
            curl ca-certificates unzip p7zip-full \
            coreutils jq git

      - name: Ensure gh CLI is available
        shell: bash
        run: |
          set -euxo pipefail
          if command -v gh >/dev/null 2>&1; then
            gh --version
          else
            echo "gh not found, installing from official repo..."
            curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg \
              | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
            sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg
            echo "deb [signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" \
              | sudo tee /etc/apt/sources.list.d/github-cli.list >/dev/null
            sudo apt-get update
            sudo apt-get install -y gh
            gh --version
          fi

      - name: Install BaiduPCS-Go
        shell: bash
        run: |
          set -euxo pipefail
          VERSION="v3.9.0"   # 可按需更新
          ARCHIVE="BaiduPCS-Go-${VERSION}-linux-amd64.zip"
          URL="https://github.com/qjfoidnh/BaiduPCS-Go/releases/download/${VERSION}/${ARCHIVE}"
          curl -L "$URL" -o /tmp/bpcs.zip
          mkdir -p /tmp/bpcs
          unzip -o /tmp/bpcs.zip -d /tmp/bpcs
          # 自动定位二进制（考虑解压到子目录）
          BPCS_BIN=$(find /tmp/bpcs -type f -name 'BaiduPCS-Go' | head -n1)
          if [[ -z "${BPCS_BIN}" ]]; then
            echo "BaiduPCS-Go binary not found in archive" >&2
            find /tmp/bpcs -maxdepth 2 -type f -print || true
            exit 1
          fi
          sudo install -m 0755 "${BPCS_BIN}" /usr/local/bin/BaiduPCS-Go
          BaiduPCS-Go -v

      - name: Login BaiduPCS-Go with Cookie
        env:
          BAIDU_COOKIE: ${{ secrets.BAIDU_COOKIE }}
        shell: bash
        run: |
          set -euxo pipefail
          if [[ -z "${BAIDU_COOKIE:-}" ]]; then
            echo "BAIDU_COOKIE is required. Add it in repository Secrets." >&2
            exit 1
          fi
          # 兼容不同分支：优先 -cookies，失败再退回 -cookie
          if ! BaiduPCS-Go login -cookies "$BAIDU_COOKIE"; then
            BaiduPCS-Go login -cookie "$BAIDU_COOKIE"
          fi
          BaiduPCS-Go who

      - name: Ensure/Create release
        env:
          GH_TOKEN: ${{ github.token }}
        shell: bash
        run: |
          set -euxo pipefail
          TAG='${{ github.event.inputs.tag }}'
          NAME='${{ github.event.inputs.name }}'
          BODY='${{ github.event.inputs.body }}'
          TARGET='${{ github.event.inputs.target }}'
          DRAFT='${{ github.event.inputs.draft }}'
          PRERELEASE='${{ github.event.inputs.prerelease }}'

          if ! gh release view "$TAG" >/dev/null 2>&1; then
            args=("$TAG")
            [[ -n "$NAME" ]] && args+=(--title "$NAME") || args+=(--title "$TAG")
            [[ -n "$BODY" ]] && args+=(--notes "$BODY") || args+=(--notes "")
            [[ -n "$TARGET" ]] && args+=(--target "$TARGET")
            [[ "$DRAFT" == "true" ]] && args+=(--draft)
            [[ "$PRERELEASE" == "true" ]] && args+=(--prerelease)
            gh release create "${args[@]}"
          fi

      - name: Download each → upload → delete (strict sequential)
        env:
          GH_TOKEN: ${{ github.token }}
        shell: bash
        run: |
          set -euo pipefail

          # 解析逗号分隔的文件路径，修剪空白并过滤空项
          RAW='${{ github.event.inputs.baidupan_files }}'
          IFS=',' read -r -a PATHS <<< "$RAW"
          cleaned=()
          for p in "${PATHS[@]}"; do
            p=$(echo "$p" | xargs)
            [[ -z "$p" ]] && continue
            cleaned+=("$p")
          done
          PATHS=("${cleaned[@]}")
          if (( ${#PATHS[@]} == 0 )); then
            echo "No valid file paths provided." >&2
            exit 1
          fi

          PART_SIZE_MB='${{ github.event.inputs.part_size_mb }}'
          TAG='${{ github.event.inputs.tag }}'
          workdir="$GITHUB_WORKSPACE/.baidu_cache"
          mkdir -p "$workdir"

          # 简单重试函数（最多 3 次）
          retry() {
            local n=0 max=3 delay=3
            until "$@"; do
              n=$((n+1))
              if (( n >= max )); then return 1; fi
              echo "Retry $n/$max: $*" >&2
              sleep $delay
            done
          }

          for remote in "${PATHS[@]}"; do
            echo "==> Processing: $remote"
            cd "$workdir"
            rm -rf ./*

            # 仅下载此文件（不递归、不批量）
            if ! retry BaiduPCS-Go download -saveto . "$remote"; then
              echo "    -> 下载失败（已重试）：$remote" >&2
              continue
            fi

            mapfile -t files < <(find . -maxdepth 1 -type f -printf '%P\n' | sort)
            if (( ${#files[@]} == 0 )); then
              echo "    -> 未找到文件（可能给了目录或无权限）：$remote" >&2
              continue
            fi

            for f in "${files[@]}"; do
              [[ -f "$f" ]] || continue
              # 计算大小（去掉重复）
              size_bytes=$(stat -c '%s' "$f")
              echo "    -> Local file: $f ($size_bytes bytes)"

              max_bytes=$(( PART_SIZE_MB * 1024 * 1024 ))

              if (( size_bytes > max_bytes )); then
                echo "    -> 7-Zip 分卷成 ${PART_SIZE_MB}MB 的 .7z.001/.002/... "

                # 压缩等级（镜像类建议 -mx=0）
                COMPRESS_LEVEL="-mx=0"

                # 目标 7z 基名
                archive="${f}.7z"

                # 分卷
                7z a -t7z $COMPRESS_LEVEL -mmt=on -v"${PART_SIZE_MB}m" -- "$archive" "$f"

                # 每个分卷校验
                sha256sum "${archive}".0* > "${archive}.sha256.txt" || true

                echo "       上传分卷……"
                for p in "${archive}".0*; do
                  echo "         -> $p"
                  retry gh release upload "$TAG" "$p" --clobber || {
                    echo "       -> 上传失败：$p" >&2; exit 1;
                  }
                done

                # 上传校验
                if [[ -f "${archive}.sha256.txt" ]]; then
                  retry gh release upload "$TAG" "${archive}.sha256.txt" --clobber || {
                    echo "       -> 上传校验失败：${archive}.sha256.txt" >&2; exit 1;
                  }
                fi

                # 清理仅在分卷分支里做
                rm -f -- "${archive}".0* 2>/dev/null || true
                rm -f -- "${archive}.sha256.txt" 2>/dev/null || true

              else
                echo "    -> 文件未超过阈值，直接上传原文件（或改为打包成单一 .7z 再传也可）"
                retry gh release upload "$TAG" "$f" --clobber || {
                  echo "       -> 上传失败：$f" >&2; exit 1;
                }
              fi

              # 无论哪条分支，最后都清理原文件
              rm -f -- "$f" || true
            done

            find . -maxdepth 1 -type f -name "._*" -delete || true
          done

          echo "All files processed sequentially."
