# ──────────────────────────────────────────────────────────────────────────────
# File: .github/workflows/baidupan-to-release.yml
# 用途：手动触发；通过 BaiduPCS-Go + Cookie 从百度网盘按“逗号分隔的完整文件路径”
#      逐个下载文件；单文件>阈值则分卷；每个文件完成后立即上传到 GitHub Release 并清理本地。
# 说明：
#  1) 仅使用浏览器 Cookie 登录：仓库 Secrets 需要 BAIDU_COOKIE。
#     建议包含：BDUSS、STOKEN、BAIDUID 等（示例：BDUSS=...; STOKEN=...; BAIDUID=...; PANWEB=1）。
#  2) 多个文件用英文逗号分隔且必须是“文件路径”（不是目录）。
#  3) 严格顺序：下载1个 →（必要时分卷）上传 → 删除本地 → 下一个。
#  4) Release 信息（tag/name/body/draft/prerelease/target）手动触发时填写；tag 必填。
# ──────────────────────────────────────────────────────────────────────────────

name: BaiduPan → GitHub Release

on:
  workflow_dispatch:
    inputs:
      tag:
        description: "Release tag（若不存在会自动创建）"
        required: true
      name:
        description: "Release 名称（可选，不填则同 tag）"
        required: false
      body:
        description: "Release 说明（可选，多行可）"
        required: false
      draft:
        description: "是否创建为 Draft（true/false）"
        default: "false"
        required: true
      prerelease:
        description: "是否标记为 Pre-release（true/false）"
        default: "false"
        required: true
      target:
        description: "目标提交/分支（默认当前默认分支）"
        required: false
      baidu_paths:
        description: |
          逗号分隔的“文件完整路径”（仅文件，非目录）。
          示例：/我的资源/文件1.iso, /我的资源/文件2.zip
        required: true
      part_size_mb:
        description: "分卷大小（MB），默认 2048（≈2GB）"
        default: "2048"
        required: true

permissions:
  contents: write

jobs:
  run:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install dependencies
        shell: bash
        run: |
          set -euxo pipefail
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends \
            curl ca-certificates unzip p7zip-full \
            coreutils jq git

      - name: Ensure gh CLI is available
        shell: bash
        run: |
          set -euxo pipefail
          if command -v gh >/dev/null 2>&1; then
            gh --version
          else
            echo "gh not found, installing from official repo..."
            curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
            sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg
            echo "deb [signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list >/dev/null
            sudo apt-get update
            sudo apt-get install -y gh
            gh --version
          fi

      - name: Download BaiduPCS-Go (Linux amd64)
        shell: bash
        run: |
          set -euxo pipefail
          VERSION="v3.9.0"  # 可按需更新
          ARCHIVE="BaiduPCS-Go-${VERSION}-linux-amd64.zip"
          URL="https://github.com/qjfoidnh/BaiduPCS-Go/releases/download/${VERSION}/${ARCHIVE}"
          curl -L "$URL" -o /tmp/bpcs.zip
          unzip -o /tmp/bpcs.zip -d /tmp/bpcs
          sudo install -m 0755 /tmp/bpcs/BaiduPCS-Go /usr/local/bin/BaiduPCS-Go
          BaiduPCS-Go -v

      - name: Login BaiduPCS-Go with Cookie
        env:
          BAIDU_COOKIE: ${{ secrets.BAIDU_COOKIE }}
        shell: bash
        run: |
          set -euxo pipefail
          if [[ -z "${BAIDU_COOKIE:-}" ]]; then
            echo "BAIDU_COOKIE is required. Please add it in repository Secrets." >&2
            exit 1
          fi
          # 兼容不同分支：优先 -cookies，失败再退回 -cookie
          if ! BaiduPCS-Go login -cookies "$BAIDU_COOKIE"; then
            BaiduPCS-Go login -cookie "$BAIDU_COOKIE"
          fi
          BaiduPCS-Go who

      - name: Create release if missing
        env:
          GH_TOKEN: ${{ github.token }}
        shell: bash
        run: |
          set -euxo pipefail
          TAG='${{ github.event.inputs.tag }}'
          NAME='${{ github.event.inputs.name }}'
          BODY='${{ github.event.inputs.body }}'
          TARGET='${{ github.event.inputs.target }}'
          DRAFT='${{ github.event.inputs.draft }}'
          PRERELEASE='${{ github.event.inputs.prerelease }}'

          if ! gh release view "$TAG" >/dev/null 2>&1; then
            args=("$TAG")
            [[ -n "$NAME" ]] && args+=(--title "$NAME") || args+=(--title "$TAG")
            [[ -n "$BODY" ]] && args+=(--notes "$BODY") || args+=(--notes "")
            [[ -n "$TARGET" ]] && args+=(--target "$TARGET")
            [[ "$DRAFT" == "true" ]] && args+=(--draft)
            [[ "$PRERELEASE" == "true" ]] && args+=(--prerelease)
            gh release create "${args[@]}"
          fi

      - name: Download each file → upload → delete (strict sequential)
        env:
          GH_TOKEN: ${{ github.token }}
        shell: bash
        run: |
          set -euo pipefail

          # ---- Parse comma-separated file paths (trim spaces, skip empties) ----
          RAW='${{ github.event.inputs.baidu_paths }}'
          IFS=',' read -r -a PATHS <<< "$RAW"
          cleaned=()
          for p in "${PATHS[@]}"; do
            p=$(echo "$p" | xargs)
            [[ -z "$p" ]] && continue
            cleaned+=("$p")
          done
          PATHS=("${cleaned[@]}")
          if (( ${#PATHS[@]} == 0 )); then
            echo "No valid file paths provided." >&2
            exit 1
          fi

          PART_SIZE_MB='${{ github.event.inputs.part_size_mb }}'
          TAG='${{ github.event.inputs.tag }}'
          workdir="$GITHUB_WORKSPACE/.baidu_cache"
          mkdir -p "$workdir"

          # ---- helper: retry command up to 3 times ----
          retry() {
            local n=0 max=3 delay=3
            until "$@"; do
              n=$((n+1))
              if (( n >= max )); then
                return 1
              fi
              echo "Retry $n/$max: $*" >&2
              sleep $delay
            done
          }

          for remote in "${PATHS[@]}"; do
            echo "==> Processing: $remote"
            cd "$workdir"
            rm -rf ./*

            # Download only this file (no directory recursion)
            if ! retry BaiduPCS-Go download -saveto . "$remote"; then
              echo "    -> 下载失败（已重试）：$remote" >&2
              continue
            fi

            mapfile -t new_files < <(find . -maxdepth 1 -type f -printf '%P\n' | sort)
            if (( ${#new_files[@]} == 0 )); then
              echo "    -> 未找到文件（可能路径是目录或无权限）：$remote" >&2
              continue
            fi

            for f in "${new_files[@]}"; do
              [[ -f "$f" ]] || continue
              size_bytes=$(stat -c '%s' "$f")
              echo "    -> Local file: $f ($size_bytes bytes)"

              max_bytes=$(( PART_SIZE_MB * 1024 * 1024 ))
              if (( size_bytes > max_bytes )); then
                echo "    -> Split into ${PART_SIZE_MB}MB parts"
                prefix="${f}.part-"
                split -b "${PART_SIZE_MB}m" -d -a 3 --additional-suffix=".bin" "$f" "$prefix"
                echo "${f}" > "${f}.manifest"
                echo "cat ${prefix}* > ${f} # reassemble" >> "${f}.manifest"

                for p in ${prefix}*; do
                  echo "       uploading $p"
                  retry gh release upload "$TAG" "$p" --clobber || {
                    echo "       -> 上传失败：$p" >&2
                    exit 1
                  }
                done
                retry gh release upload "$TAG" "${f}.manifest" --clobber || {
                  echo "       -> 上传 manifest 失败：${f}.manifest" >&2
                  exit 1
                }
              else
                echo "    -> Uploading single file"
                retry gh release upload "$TAG" "$f" --clobber || {
                  echo "       -> 上传失败：$f" >&2
                  exit 1
                }
              fi

              # cleanup this file (keep workspace minimal)
              rm -f -- "$f" || true
              rm -f -- ${f}.part-* 2>/dev/null || true
            done

            find . -maxdepth 1 -type f -name "._*" -delete || true
          done

          echo "All files processed sequentially."
